name: Build CEF

on:
  workflow_dispatch:
    inputs:
      runner_mode:
        description: "Runner mode"
        required: true
        type: choice
        default: shared
        options:
          - shared
          - self-hosted
      cef_version:
        description: "CEF version/tag/branch (example: 132.3.0 or 6533)"
        required: true
        type: string
        default: "latest"
      publish_release:
        description: "Create/update GitHub Release with build artifacts"
        required: true
        type: boolean
        default: false
  schedule:
    - cron: "0 2 * * 1"

concurrency:
  group: cef-build-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  build:
    name: ${{ matrix.id }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - id: windows-x64
            shared_runs_on: '["windows-2022"]'
            self_runs_on: '["self-hosted","cef","windows","x64"]'
            build_flag: --x64-build
            extra_env: ""
          - id: linux-x64
            shared_runs_on: '["ubuntu-24.04"]'
            self_runs_on: '["self-hosted","cef","linux","x64"]'
            build_flag: --x64-build
            extra_env: ""
          - id: macos-x64
            shared_runs_on: '["macos-15"]'
            self_runs_on: '["self-hosted","cef","macos","x64"]'
            build_flag: --x64-build
            extra_env: CEF_ENABLE_AMD64=1
          - id: macos-arm64
            shared_runs_on: '["macos-15"]'
            self_runs_on: '["self-hosted","cef","macos","arm64"]'
            build_flag: --arm64-build
            extra_env: ""

    runs-on: ${{ fromJson(((github.event.inputs.runner_mode || 'shared') == 'self-hosted') && matrix.self_runs_on || matrix.shared_runs_on) }}

    env:
      RUNNER_MODE: ${{ github.event.inputs.runner_mode || 'shared' }}
      CEF_VERSION: ${{ github.event.inputs.cef_version || vars.CEF_VERSION || vars.CEF_BRANCH || 'latest' }}
      CEF_GN_DEFINES: ${{ vars.CEF_GN_DEFINES || 'is_official_build=true proprietary_codecs=true ffmpeg_branding=Chrome enable_platform_hevc=true enable_hevc_parser_and_hw_decoder=true' }}
      CEF_FAST_GN_DEFINES: ${{ vars.CEF_FAST_GN_DEFINES || 'symbol_level=0 blink_symbol_level=0 v8_symbol_level=0 use_jumbo_build=true' }}
      SCCACHE_CACHE_SIZE: ${{ vars.SCCACHE_CACHE_SIZE || '80G' }}
      SCCACHE_IDLE_TIMEOUT: "0"
      SCCACHE_DIRECT: "true"
      SCCACHE_IGNORE_SERVER_IO_ERROR: "1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Resolve paths
        id: paths
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${RUNNER_MODE}" == "self-hosted" ]]; then
            base="${{ vars.CEF_CACHE_ROOT }}"
            if [[ -z "${base}" ]]; then
              base="${HOME}/cef-cache"
            fi
          else
            base="${GITHUB_WORKSPACE}/.cef-cache"
          fi

          download_dir="${base}/${{ matrix.id }}"
          depot_tools_dir="${download_dir}/depot_tools"
          git_cache_dir="${base}/git-cache/${{ matrix.id }}"
          sccache_dir="${base}/sccache/${{ matrix.id }}"
          script_path="${download_dir}/automate-git.py"

          mkdir -p "${download_dir}" "${git_cache_dir}" "${sccache_dir}"

          echo "download_dir=${download_dir}" >> "${GITHUB_OUTPUT}"
          echo "depot_tools_dir=${depot_tools_dir}" >> "${GITHUB_OUTPUT}"
          echo "git_cache_dir=${git_cache_dir}" >> "${GITHUB_OUTPUT}"
          echo "sccache_dir=${sccache_dir}" >> "${GITHUB_OUTPUT}"
          echo "script_path=${script_path}" >> "${GITHUB_OUTPUT}"

          echo "RUNNER_MODE=${RUNNER_MODE}"
          echo "CEF_VERSION=${CEF_VERSION}"
          echo "CEF_GN_DEFINES=${CEF_GN_DEFINES}"
          echo "CEF_FAST_GN_DEFINES=${CEF_FAST_GN_DEFINES}"
          echo "DOWNLOAD_DIR=${download_dir}"
          echo "GIT_CACHE_DIR=${git_cache_dir}"
          echo "SCCACHE_DIR=${sccache_dir}"

      - name: Resolve CEF version to branch/checkout
        id: cef
        shell: bash
        run: |
          set -euo pipefail

          python - <<'PY'
          import json
          import os
          import re
          import sys
          from urllib.request import urlopen

          input_value = os.environ["CEF_VERSION"].strip()
          out = os.environ["GITHUB_OUTPUT"]

          def walk_versions(obj, out_versions):
            if isinstance(obj, dict):
              if "cef_version" in obj and isinstance(obj["cef_version"], str):
                out_versions.add(obj["cef_version"])
              for v in obj.values():
                walk_versions(v, out_versions)
            elif isinstance(obj, list):
              for v in obj:
                walk_versions(v, out_versions)

          def parse_version(v):
            m = re.match(r"^(\d+)\.(\d+)\.(\d+)\+g([0-9a-f]+)\+chromium-(\d+)\.(\d+)\.(\d+)\.(\d+)$", v)
            if not m:
              return None
            return {
              "cef_major": int(m.group(1)),
              "cef_minor": int(m.group(2)),
              "cef_patch": int(m.group(3)),
              "git_hash": m.group(4),
              "chromium_major": int(m.group(5)),
              "chromium_minor": int(m.group(6)),
              "chromium_branch": int(m.group(7)),
              "chromium_patch": int(m.group(8)),
              "raw": v,
            }

          if re.fullmatch(r"[0-9]{4,}", input_value):
            with open(out, "a", encoding="utf-8") as f:
              f.write(f"branch={input_value}\n")
              f.write("checkout=\n")
              f.write(f"resolved_version={input_value}\n")
            print(f"Resolved CEF input '{input_value}' -> branch={input_value} checkout=<latest-on-branch>")
            sys.exit(0)

          with urlopen("https://cef-builds.spotifycdn.com/index.json") as r:
            index_json = json.load(r)

          versions = set()
          walk_versions(index_json, versions)
          parsed = [p for p in (parse_version(v) for v in versions) if p is not None]
          if not parsed:
            print("No CEF versions found in spotify index", file=sys.stderr)
            sys.exit(1)

          if input_value == "latest":
            chosen = max(
              parsed,
              key=lambda p: (
                p["cef_major"], p["cef_minor"], p["cef_patch"],
                p["chromium_major"], p["chromium_minor"], p["chromium_branch"], p["chromium_patch"],
              ),
            )
          else:
            exact = [p for p in parsed if p["raw"] == input_value]
            prefix = [p for p in parsed if p["raw"].startswith(input_value + "+g")]
            candidates = exact or prefix
            if not candidates:
              print(f"Cannot resolve CEF version/tag from input: {input_value}", file=sys.stderr)
              sys.exit(1)
            chosen = max(
              candidates,
              key=lambda p: (
                p["cef_major"], p["cef_minor"], p["cef_patch"],
                p["chromium_major"], p["chromium_minor"], p["chromium_branch"], p["chromium_patch"],
              ),
            )

          branch = str(chosen["chromium_branch"])
          checkout = chosen["git_hash"]
          resolved = chosen["raw"]

          with open(out, "a", encoding="utf-8") as f:
            f.write(f"branch={branch}\n")
            f.write(f"checkout={checkout}\n")
            f.write(f"resolved_version={resolved}\n")

          print(f"Resolved CEF input '{input_value}' -> version={resolved} branch={branch} checkout={checkout}")
          PY

      - name: Cache bootstrap and compiler cache (shared runner only)
        if: ${{ env.RUNNER_MODE == 'shared' }}
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.paths.outputs.depot_tools_dir }}
            ${{ steps.paths.outputs.git_cache_dir }}
            ${{ steps.paths.outputs.sccache_dir }}
          key: cef-bootstrap-${{ matrix.id }}-${{ steps.cef.outputs.branch }}-${{ hashFiles('.github/workflows/cef-build.yml') }}
          restore-keys: |
            cef-bootstrap-${{ matrix.id }}-${{ steps.cef.outputs.branch }}-
            cef-bootstrap-${{ matrix.id }}-

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Configure sccache backend
        shell: bash
        run: |
          set -euo pipefail
          echo "SCCACHE_DIR=${{ steps.paths.outputs.sccache_dir }}" >> "${GITHUB_ENV}"
          echo "SCCACHE_CACHE_SIZE=${SCCACHE_CACHE_SIZE}" >> "${GITHUB_ENV}"
          if [[ "${RUNNER_MODE}" == "shared" ]]; then
            echo "SCCACHE_GHA_ENABLED=true" >> "${GITHUB_ENV}"
          else
            echo "SCCACHE_GHA_ENABLED=false" >> "${GITHUB_ENV}"
          fi

      - name: Warm up sccache
        shell: bash
        run: |
          set -euo pipefail
          "${SCCACHE_PATH:-sccache}" --start-server || true
          "${SCCACHE_PATH:-sccache}" --zero-stats || true

      - name: Fetch automate-git.py
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL \
            https://raw.githubusercontent.com/chromiumembedded/cef/master/tools/automate/automate-git.py \
            -o "${{ steps.paths.outputs.script_path }}"

      - name: Build CEF
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "${{ matrix.extra_env }}" ]]; then
            export ${{ matrix.extra_env }}
          fi

          export GIT_CACHE_PATH="${{ steps.paths.outputs.git_cache_dir }}"
          export GN_DEFINES="${CEF_GN_DEFINES} ${CEF_FAST_GN_DEFINES} cc_wrapper=\"sccache\""

          checkout_args=()
          if [[ -n "${{ steps.cef.outputs.checkout }}" ]]; then
            checkout_args+=(--checkout="${{ steps.cef.outputs.checkout }}")
          fi

          python "${{ steps.paths.outputs.script_path }}" \
            --download-dir="${{ steps.paths.outputs.download_dir }}" \
            --depot-tools-dir="${{ steps.paths.outputs.download_dir }}/depot_tools" \
            --branch="${{ steps.cef.outputs.branch }}" \
            "${checkout_args[@]}" \
            --minimal-distrib \
            --client-distrib \
            --no-chromium-history \
            --no-debug-build \
            ${{ matrix.build_flag }}

      - name: Show sccache stats
        if: ${{ always() }}
        shell: bash
        run: |
          set +e
          "${SCCACHE_PATH:-sccache}" --show-stats
          "${SCCACHE_PATH:-sccache}" --stop-server

      - name: Upload binary distrib
        uses: actions/upload-artifact@v4
        with:
          name: cef-${{ matrix.id }}-branch-${{ steps.cef.outputs.branch }}-${{ steps.cef.outputs.checkout != '' && 'pinned' || 'head' }}
          path: ${{ steps.paths.outputs.download_dir }}/chromium/src/cef/binary_distrib/
          if-no-files-found: error
          retention-days: 7

  release:
    name: Release
    needs: build
    if: ${{ github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.publish_release || 'false') }}
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    env:
      CEF_VERSION: ${{ github.event.inputs.cef_version || vars.CEF_VERSION || vars.CEF_BRANCH || 'latest' }}
    steps:
      - name: Resolve release tag
        id: rel
        shell: bash
        run: |
          set -euo pipefail

          python - <<'PY'
          import json
          import os
          import re
          import sys
          from urllib.request import urlopen

          input_value = os.environ["CEF_VERSION"].strip()
          out = os.environ["GITHUB_OUTPUT"]

          if re.fullmatch(r"[0-9]{4,}", input_value):
            print(
              f"publish_release=true requires a version input (e.g. 145.0.26 or latest), not a raw branch number ({input_value}).",
              file=sys.stderr,
            )
            sys.exit(1)

          def walk_versions(obj, out_versions):
            if isinstance(obj, dict):
              if "cef_version" in obj and isinstance(obj["cef_version"], str):
                out_versions.add(obj["cef_version"])
              for v in obj.values():
                walk_versions(v, out_versions)
            elif isinstance(obj, list):
              for v in obj:
                walk_versions(v, out_versions)

          def parse_version(v):
            m = re.match(r"^(\d+)\.(\d+)\.(\d+)\+g([0-9a-f]+)\+chromium-(\d+)\.(\d+)\.(\d+)\.(\d+)$", v)
            if not m:
              return None
            return {
              "cef_major": int(m.group(1)),
              "cef_minor": int(m.group(2)),
              "cef_patch": int(m.group(3)),
              "git_hash": m.group(4),
              "chromium_major": int(m.group(5)),
              "chromium_minor": int(m.group(6)),
              "chromium_branch": int(m.group(7)),
              "chromium_patch": int(m.group(8)),
              "raw": v,
            }

          with urlopen("https://cef-builds.spotifycdn.com/index.json") as r:
            index_json = json.load(r)

          versions = set()
          walk_versions(index_json, versions)
          parsed = [p for p in (parse_version(v) for v in versions) if p is not None]
          if not parsed:
            print("No CEF versions found in spotify index", file=sys.stderr)
            sys.exit(1)

          if input_value == "latest":
            chosen = max(
              parsed,
              key=lambda p: (
                p["cef_major"], p["cef_minor"], p["cef_patch"],
                p["chromium_major"], p["chromium_minor"], p["chromium_branch"], p["chromium_patch"],
              ),
            )
          else:
            exact = [p for p in parsed if p["raw"] == input_value]
            prefix = [p for p in parsed if p["raw"].startswith(input_value + "+g")]
            candidates = exact or prefix
            if not candidates:
              print(f"Cannot resolve release version from CEF_VERSION={input_value}", file=sys.stderr)
              sys.exit(1)
            chosen = max(
              candidates,
              key=lambda p: (
                p["cef_major"], p["cef_minor"], p["cef_patch"],
                p["chromium_major"], p["chromium_minor"], p["chromium_branch"], p["chromium_patch"],
              ),
            )

          resolved = chosen["raw"]
          release_tag = f"cef-{resolved}"
          release_name = f"CEF {resolved}"

          with open(out, "a", encoding="utf-8") as f:
            f.write(f"checkout={resolved}\n")
            f.write(f"release_tag={release_tag}\n")
            f.write(f"release_name={release_name}\n")

          print(f"Resolved release: {release_tag}")
          PY

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: cef-*
          path: release-assets

      - name: List release files
        shell: bash
        run: |
          set -euo pipefail
          find release-assets -type f | sort

      - name: Pack release bundles
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release-bundles
          for artifact_dir in release-assets/*; do
            if [[ -d "${artifact_dir}" ]]; then
              base="$(basename "${artifact_dir}")"
              tar -C "${artifact_dir}" -cjf "release-bundles/${base}.tar.bz2" .
            fi
          done
          ls -lh release-bundles

      - name: Create or update release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.rel.outputs.release_tag }}
          name: ${{ steps.rel.outputs.release_name }}
          generate_release_notes: true
          prerelease: false
          files: |
            release-bundles/*.tar.bz2
